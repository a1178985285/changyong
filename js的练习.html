<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title></title>
	</head>
	<body>

	</body>
</html>
<script>
	//执行的函数
	// function app(event){
	// 	console.log(event)
	// 不要执行与事件关联的默认动作
	// event.preventDefault();
	// }

	//			闭包
	// function p1(){
	// 	var pp=200
	// 	 function p2(){
	// 		return pp+2000
	// 	}
	// 	return p2()
	// }
	// console.log(p1())
	//或者这样
	// var p3=p1()
	// console.log(p3)

	//拓展运算符是浅拷贝
	//浅拷贝 浅拷贝是拷贝了对象的引用,只复制了引用地址,并非堆里面的值,数组和对象一样
	// var  arr6=[1,2,3,4]
	// arr7=arr6
	// console.log(arr6===arr7)
	//一起改变
	// arr6[0]=0;
	// console.log(arr6,arr7)
	//拓展运算符是浅拷贝
	// var a1=[1,2,5]
	// var a3=[...a1]
	// console.log(a3)

	// //深拷贝的方法   用JSON.stringify和JSON.parse
	// var a1= [1,2,3,4]
	// a2=JSON.stringify(a1)
	// a1[3]=10
	// console.log(a1)
	// console.log(JSON.parse(a2))

	//数组合并  前一个a1是合并后的数组1,2,3,4,5,6
	// var a1=[1,2,3]
	// var a2=[4,5,6]
	// a1.push.apply(a1,a2)
	// console.log(a1)
	// console.log(a2)

	//数组合并  会返回一个新数组 concat性能好
	// var a1=[1,2,3]
	// var a2=[4,5,6]
	// var a3=a1.concat(a2)
	// console.log(a3)

	// var a1=[{name:"zhang",age:16},{name:"li",age:12}];
	// var a2=[{name:"55541",age:20},{name:"555",age:10}];
	// var a3=a1.concat(a2)
	// console.log(a3)

	//对象的合并  o1也会被改变
	// var o1={name:"张三",age:16};
	// var o2={city:"chen"}
	// var  o3= Object.assign(o1,o2)
	// console.log(o3)

	//幂运算 平方
	// var a=3;				
	// var b=a**3				
	// console.log(b)

	//set 数组去重
	// var  a1=[1,1,1,1,1,2]
	// var a2=Array.from(new Set(a1))  
	// console.log(a2)

	//字符串拼接
	// var str1="fdffdf";
	// var str2="dscxcxcxcx"
	// //把str1连接到str2上
	// console.log(str1+str2);
	// console.log(typeof(str1+str2));

	//获取当前的时间戳
	// var d= Date.parse(new Date())
	// console.log(d)
	// 
	// //获取当前的时间
	// var d=new Date()
	// console.log(d)

	// function abb(){
	// 	console.log("线输出的")
	// };
	// 
	// setTimeout(abb(),10000)

	//对象增删改
	// var a={name:"dsda",age:"555"};
	// //修改
	// a.name="name";
	// //添加
	// a.city="city";
	// //删除
	// delete a.name
	// console.log(a)


	//删除函数
	// function add(){
	// 	console.log(2233)
	// }
	// console.log(add())
	// // 		arr.push( 'A', 'B' );
	// 		console.log( arr ); 

	//splice   改变原来的数组
	//第一个参数,从哪里开始删除
	//第二个参数（要删除的个数）
	//第三个参数 是要添加的元素
	// var a=[1,2,3,4,5];
	// a.splice(4,1)
	// console.log(a)

	//pop push shift  unshift  都会改变原数组
	// var a=[1,2,3,4,5];
	// var b=a.length
	// for (var i = 0; i <= b; i++) {
	// 	a.unshift(0)
	// }
	// console.log(a)


	//join分割  不会改变原数组,会把数组转换成字符串
	// var a=[1,2,3,4,5];  
	// var b=a.join("")
	// console.log(typeof(b))


	//split 字符串转换成数组  " "中间有空格,连接在一起,""没空格,分割开
	// var a="123456"
	// var b=a.split(" ")
	// console.log(b)

	// var add=1;
	// //存localStorage
	// localStorage.setItem("add",add)
	// //修改localStorage
	// localStorage.removeItem("add")

	//reverse颠倒数组的顺序

	//从大到小排列
	// let arr =[1,3,4,6,0,24,54,34,28]
	// arr.sort(function (m, n) {
	// 		return m-n	
	// });
	// console.log(arr)

	// filter  不会改变原数组 进行判断
	// var a1=[1,2,3,4,5]
	// var a2=a1.filter(function(value,key){
	// 	return value>2
	// })
	// console.log(a2)

	//map用法   不会改变原数组
	// var a1=[1,2,3,4,5]
	// var a2=a1.map(function(value,key,arr){
	// 	return value*2
	// })
	// console.log(a2)

	//indexOf用法  获取第一次出现的位置
	// var a1="gfgqrtuiuplv xvsttgjkfl"
	// var a2=a1.indexOf("v")
	// console.log(a2)

	//every 将每个元素进行判断返回一个布尔值
	// var a1=[1,2,3,4]
	// var a2=a1.every(function(value){
	// 		return value>3
	// })
	
	//reduce求和			比较深入
	// var a1=[1,2,3,4,5,6];
	// var a2=a1.reduce(function(value,key){
	// 	return value+key
	// })
	// console.log(a2)
	

			

	// function setCookieValue(key,value){
	//     var date = new Date();
	//      var dataO=date.setTime(date.getTime()+100*24*3600*1000);
	// 	console.log(date.getTime())
	// }
	// 
	// setCookieValue()
	// 
	// 
	//正则

	// 
	// var str = 'abc123de45fgh6789qqq111';
	// var str = 'bbc123de45fgh6789qqq111';
	// var reg=/^a/;
	// console.log(str.match(reg))


	//搜索
</script>
